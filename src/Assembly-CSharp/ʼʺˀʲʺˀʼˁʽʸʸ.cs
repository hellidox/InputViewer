using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

public abstract class \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8
{
	public \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8(uint \u02B4\u02BC\u02B5\u02B9\u02B8\u02BB\u02B4\u02BB\u02BE\u02BC\u02BC)
	{
		this.\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 = \u02B4\u02BC\u02B5\u02B9\u02B8\u02BB\u02B4\u02BB\u02BE\u02BC\u02BC;
	}

	public float \u02B2\u02B8\u02BA\u02BA\u02BC\u02B7\u02B5\u02B5\u02B6\u02B5\u02C1
	{
		get
		{
			return this.\u02B4\u02BC\u02BF\u02BC\u02BA\u02B9\u02B8\u02B2\u02BD\u02BE\u02BD.\u02B9\u02B4\u02B6\u02B8\u02BE\u02B2\u02B6\u02C0\u02BC\u02BA\u02B7(this.\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8);
		}
	}

	public static int \u02B9\u02B6\u02BF\u02BF\u02B3\u02BC\u02BC\u02B2\u02BF\u02BF\u02BC<T>(uint \u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8, IList<T> \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD) where T : \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8
	{
		int i = 0;
		int num = \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD.Count - 1;
		int num2 = -1;
		while (i <= num)
		{
			int num3 = (i + num) / 2;
			num2 = num3;
			if (\u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD[num3].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 == \u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8)
			{
				break;
			}
			if (\u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD[num3].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 < \u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8)
			{
				i = num3 + 1;
			}
			else
			{
				num = num3 - 1;
			}
		}
		return num2;
	}

	[return: TupleElementNames(new string[] { "minIndex", "maxIndex" })]
	public static ValueTuple<int, int> \u02B2\u02B4\u02BB\u02B4\u02BF\u02B2\u02B2\u02BB\u02BA\u02B9\u02B8<T>(uint \u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8, List<T> \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD) where T : \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8
	{
		int num = \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8.\u02B9\u02B6\u02BF\u02BF\u02B3\u02BC\u02BC\u02B2\u02BF\u02BF\u02BC<T>(\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8, \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD);
		if (num != -1 && \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD[num].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 == \u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8)
		{
			int i = num;
			int num2 = num;
			while (i > 0)
			{
				if (\u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD[num].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 != \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD[i - 1].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8)
				{
					break;
				}
				i--;
			}
			while (num2 < \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD.Count - 1 && \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD[num].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 == \u02C0\u02BE\u02B5\u02BE\u02BC\u02BC\u02BF\u02BE\u02B6\u02B6\u02BD[num2 + 1].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8)
			{
				num2++;
			}
			return new ValueTuple<int, int>(i, num2);
		}
		return new ValueTuple<int, int>(-1, -1);
	}

	[return: TupleElementNames(new string[] { "minIndex", "maxIndex" })]
	public static ValueTuple<int, int> \u02BE\u02C1\u02B2\u02BB\u02B9\u02BD\u02B6\u02B9\u02B6\u02B2\u02B9<T>(IList<T> \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA, uint \u02B6\u02B4\u02B2\u02C0\u02BA\u02C1\u02B7\u02B8\u02B6\u02BD\u02B5, uint \u02B9\u02B2\u02BB\u02BE\u02B4\u02BF\u02BD\u02B6\u02BB\u02BF\u02B3) where T : \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8
	{
		if (\u02B6\u02B4\u02B2\u02C0\u02BA\u02C1\u02B7\u02B8\u02B6\u02BD\u02B5 > \u02B9\u02B2\u02BB\u02BE\u02B4\u02BF\u02BD\u02B6\u02BB\u02BF\u02B3 || \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA.Count < 1)
		{
			return new ValueTuple<int, int>(-1, -1);
		}
		int num = \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8.\u02B9\u02B6\u02BF\u02BF\u02B3\u02BC\u02BC\u02B2\u02BF\u02BF\u02BC<T>(\u02B6\u02B4\u02B2\u02C0\u02BA\u02C1\u02B7\u02B8\u02B6\u02BD\u02B5, \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA);
		int num2 = \u02BC\u02BA\u02C0\u02B2\u02BA\u02C0\u02BC\u02C1\u02BD\u02B8\u02B8.\u02B9\u02B6\u02BF\u02BF\u02B3\u02BC\u02BC\u02B2\u02BF\u02BF\u02BC<T>(\u02B9\u02B2\u02BB\u02BE\u02B4\u02BF\u02BD\u02B6\u02BB\u02BF\u02B3, \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA);
		if (num == -1 || num2 == -1)
		{
			return new ValueTuple<int, int>(-1, -1);
		}
		while (num < \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA.Count && \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA[num].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 < \u02B6\u02B4\u02B2\u02C0\u02BA\u02C1\u02B7\u02B8\u02B6\u02BD\u02B5)
		{
			num++;
		}
		if (num > \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA.Count - 1)
		{
			return new ValueTuple<int, int>(-1, -1);
		}
		while (num - 1 >= 0)
		{
			if (\u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA[num - 1].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 < \u02B6\u02B4\u02B2\u02C0\u02BA\u02C1\u02B7\u02B8\u02B6\u02BD\u02B5)
			{
				break;
			}
			num--;
		}
		while (num2 >= 0 && \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA[num2].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 > \u02B9\u02B2\u02BB\u02BE\u02B4\u02BF\u02BD\u02B6\u02BB\u02BF\u02B3)
		{
			num2--;
		}
		if (num2 < 0)
		{
			return new ValueTuple<int, int>(-1, -1);
		}
		while (num2 + 1 < \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA.Count && \u02B6\u02BF\u02BF\u02B8\u02B9\u02B5\u02BA\u02B5\u02B5\u02C1\u02BA[num2 + 1].\u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8 <= \u02B9\u02B2\u02BB\u02BE\u02B4\u02BF\u02BD\u02B6\u02BB\u02BF\u02B3)
		{
			num2++;
		}
		if (num > num2)
		{
			return new ValueTuple<int, int>(-1, -1);
		}
		return new ValueTuple<int, int>(num, num2 + 1);
	}

	[NonSerialized]
	public \u02B7\u02BD\u02BB\u02BB\u02BF\u02B5\u02C0\u02C1\u02BD\u02B3\u02B6 \u02B4\u02BC\u02BF\u02BC\u02BA\u02B9\u02B8\u02B2\u02BD\u02BE\u02BD;

	public uint \u02B3\u02BF\u02B9\u02BA\u02B5\u02B9\u02B7\u02BC\u02BC\u02B8\u02B8;

	public const int \u02C1\u02B6\u02B3\u02BD\u02C0\u02BF\u02BA\u02B5\u02B4\u02BC\u02C1 = -1;
}
